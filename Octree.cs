//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Threading;
using UnityEngine;
using NuHash.UsefulUtilities;
public class Octree
{
	public OctreeData data;
	public byte[] baseTrace;
	public Vector3 position;
	public float boxLength;
	List<ReadOnlyCollection<byte>> leaves = new List<ReadOnlyCollection<byte>>(12000000);
	Int64 queuedItems;
	List<ThreadObject> queuedLeaves = new List<ThreadObject>(6000000);
	readonly object _lock = new object();

	private class ThreadObject{
		public ReadOnlyCollection<byte> trace;
		public float length;
		public Vector3 pos;
	}

//	public bool IsSplit {
//		get{return (child != null);}
//	}
//	
//	public Octree Child(int idx) {
//		if(idx>7 || idx<0 || !this.IsSplit)
//		{
//			Debug.LogError("No children available or index is out of range");
//			return null;
//		}
//		return child[idx];
//	}
	
	public Octree (OctreeData data,Vector3 position,float length,byte[] trace)
	{
		this.baseTrace = trace;
		this.position = position;
		this.data = data;
		this.boxLength = length;
	}

	public void Split()
	{
		List<byte> trace = new List<byte>{0};
		if(data.splitPolicy(position,boxLength,trace.AsReadOnly()))
		{
			float newLength = boxLength/2;
			queuedItems += 8;
			trace.Add(0);
			for (byte i = 0; i < 8; i++) {
				trace[1] = i;
				ThreadObject tO = new ThreadObject(){
					trace = Array.AsReadOnly(trace.ToArray()),
					length = newLength,
					pos = GetChildPos(position,boxLength,i),
				};
				queuedLeaves.Add(tO);
				//ThreadPool.QueueUserWorkItem(new WaitCallback(SplitThread));
				Thread thread = new Thread(new ThreadStart(SplitThread));
				thread.Start();
			}
//			SplitThread();
		}
		else{
			leaves.Add(trace.AsReadOnly());
		}
	}

	private void SplitThread()//byte[] trace,ref float length)
	{
		ThreadObject a;
		lock(_lock){
			a = queuedLeaves[queuedLeaves.Count-1];
			queuedLeaves.RemoveAt(queuedLeaves.Count-1);
		}
		while(true){
			var trace = a.trace;
			float length = a.length;
			Vector3 cellPos = a.pos;
			if(data.splitPolicy(cellPos,length,trace))
			{
				List<byte> newTrace = new List<byte>(trace);
				newTrace.Add(0);
				float newLength = length/2;
				Interlocked.Add(ref queuedItems,8);
				for (byte i = 0; i < 8; i++) {
					newTrace[trace.Count] = i;
					var currentTrace= newTrace.ToArray();
					ThreadObject tO = new ThreadObject(){
						trace = Array.AsReadOnly(currentTrace),
						length = newLength,
						pos = GetChildPos(cellPos,length,i)
					};
					lock(_lock){
						queuedLeaves.Add(tO);
					}

				}
			}else{
				lock(_lock){
					leaves.Add(trace);
				}
			}
			Interlocked.Decrement(ref queuedItems);
			lock(_lock){
				if(queuedLeaves.Count <1)
					break;
				a = queuedLeaves[queuedLeaves.Count-1];
				queuedLeaves.RemoveAt(queuedLeaves.Count-1);
			}
		}
		if(queuedItems==0)
		{
			Debug.Log("Split complete");
			Debug.Log(leaves.Count+" leaves.");
		}
	}

	public static UInt64 ChildTrace(UInt64 trace){
		byte level = TraceToLevel(trace);
		return LevelToTrace((byte)(level+1))+8*(trace-LevelToTrace(level));
	}

	public static UInt64 ChildTrace(UInt64 trace,byte level){
		return LevelToTrace((byte)(level+1))+8*(trace-LevelToTrace(level));
	}
	
	public static byte TraceToLevel(UInt64 trace)
	{
		return (byte)(NMath.Log2_64((7*trace/8)+1)/3);
	}

	public static UInt64 LevelToTrace(byte level)
	{
		return (UInt64)(1<<(3*level) - 1)*8/7;
	}

	public Vector3 TraceToPosition(byte[] trace)
	{
		Vector3 pos = position;
		float len = boxLength;
		for (int i = 1; i < trace.Length; i++) {
			pos = GetChildPos(pos,len,trace[i]);
			len = len/2;
		}
		return pos;
	}

	public Vector3 TraceToPosition(UInt64 trace)
	{
		if(trace==0)
			return position;
		UInt64 level = NMath.Log2_64(7*trace/8+1)/3ul -1ul;
		Vector3 pos = position;
		float len = boxLength;
		UInt64 nCells = NMath.IntPow(8,level);
		while(level>0){
			UInt64 rPos = trace - nCells/8;
			byte childNum = (byte)(8*rPos/nCells);
			pos = GetChildPos(pos,len,childNum);
			len = len/2;
			nCells = nCells/8;
			level--;
		}
		return pos;
	}

	public static Vector3 GetChildPos(Vector3 oldCenter, float oldLength, byte childNum)
	{
		Vector3 result;
		Vector3 diff;
		switch(childNum)
		{
		case 0:
			diff = -0.25f*new Vector3(oldLength,oldLength,oldLength);
			result = oldCenter + diff;
			break;
		case 1:
			diff = 0.25f*new Vector3(oldLength,-oldLength,-oldLength);
			result = oldCenter + diff;
			break;
		case 2:
			diff = 0.25f*new Vector3(oldLength,-oldLength,oldLength);
			result = oldCenter + diff;
			break;
		case 3:
			diff = 0.25f*new Vector3(-oldLength,-oldLength,oldLength);
			result = oldCenter + diff;
			break;
		case 4:
			diff = 0.25f*new Vector3(-oldLength,oldLength,-oldLength);
			result = oldCenter + diff;
			break;
		case 5:
			diff = 0.25f*new Vector3(oldLength,oldLength,-oldLength);
			result = oldCenter + diff;
			break;
		case 6:
			diff = 0.25f*new Vector3(oldLength,oldLength,oldLength);
			result = oldCenter + diff;
			break;
		case 7:
			diff = 0.25f*new Vector3(-oldLength,oldLength,oldLength);
			result = oldCenter + diff;
			break;
		default:
			Debug.LogError("Invalid child number");
			result = Vector3.zero;
			break;
		}
		return result;
	}

	public static Vector3 GetCornerPos(Vector3 center, float length, byte cornerNum)
	{
		Vector3 result;
		Vector3 diff;
		switch(cornerNum)
		{
		case 0:
			diff = -0.5f*new Vector3(length,length,length);
			result = center + diff;
			break;
		case 1:
			diff = 0.5f*new Vector3(length,-length,-length);
			result = center + diff;
			break;
		case 2:
			diff = 0.5f*new Vector3(length,-length,length);
			result = center + diff;
			break;
		case 3:
			diff = 0.5f*new Vector3(-length,-length,length);
			result = center + diff;
			break;
		case 4:
			diff = 0.5f*new Vector3(-length,length,-length);
			result = center + diff;
			break;
		case 5:
			diff = 0.5f*new Vector3(length,length,-length);
			result = center + diff;
			break;
		case 6:
			diff = 0.5f*new Vector3(length,length,length);
			result = center + diff;
			break;
		case 7:
			diff = 0.5f*new Vector3(-length,length,length);
			result = center + diff;
			break;
		default:
			Debug.LogError("Invalid corner number");
			result = Vector3.zero;
			break;
		}
		return result;
	}

	public static Vector3[] GetCornersPos(Vector3 center, float length)
	{
		Vector3[] results = new Vector3[8];
		for (byte i = 0; i < 8; i++) {
			results[i] = GetCornerPos(center,length,i);
		}
		return results;
	}

	public static void GetCornersPos(Vector3 center, float length, ref Vector3[] results)
	{
		if(!(results.Length >= 8)){
			throw new IndexOutOfRangeException("Number of elements in results array is not enough to accomodate positions");
		}
		for (byte i = 0; i < 8; i++) {
			results[i] = GetCornerPos(center,length,i);
		}
		return;
	}

	
	public static Vector3 GetMidPointPos(Vector3 center, float length, byte posNum)
	{
		Vector3 result,diff;
		switch(posNum)
		{
		case 0:
			diff = new Vector3(0,-length,-length);
			result = center + diff;
			break;
		case 1:
			diff = new Vector3(length,-length,0);
			result = center + diff;
			break;
		case 2:
			diff = new Vector3(0,-length,length);
			result = center + diff;
			break;
		case 3:
			diff = new Vector3(-length,-length,0);
			result = center + diff;
			break;
		case 4:
			diff = new Vector3(0,-length,0);
			result = center + diff;
			break;
		case 5:
			diff = new Vector3(-length,0,-length);
			result = center + diff;
			break;
		case 6:
			diff = new Vector3(0,0,-length);
			result = center + diff;
			break;
		case 7:
			diff = new Vector3(length,0,-length);
			result = center + diff;
			break;
		case 8:
			diff = new Vector3(length,0,0);
			result = center + diff;
			break;
		case 9:
			diff = new Vector3(length,0,length);
			result = center + diff;
			break;
		case 10:
			diff = new Vector3(0,0,length);
			result = center + diff;
			break;
		case 11:
			diff = new Vector3(-length,0,length);
			result = center + diff;
			break;
		case 12:
			diff = new Vector3(-length,0,0);
			result = center + diff;
			break;
		case 13:
			result = center;
			break;
		case 14:
			diff = new Vector3(0,length,-length);
			result = center + diff;
			break;
		case 15:
			diff = new Vector3(length,0,0);
			result = center + diff;
			break;
		case 16:
			diff = new Vector3(0,length,length);
			result = center + diff;
			break;
		case 17:
			diff = new Vector3(-length,length,0);
			result = center + diff;
			break;
		case 18:
			diff = new Vector3(0,length,0);
			result = center + diff;
			break;
		default:
			Debug.LogError("Invalid corner number");
			result = Vector3.zero;
			break;
		}
		return result;
	}

	public static Vector3[] GetMidPointsPos(Vector3 center, float length)
	{
		Vector3[] results = new Vector3[19];
		for (byte i = 0; i < 19; i++) {
			results[i] = GetMidPointPos(center,length,i);
		}
		return results;
	}

	public static void GetMidPointsPos(Vector3 center, float length,ref Vector3[] results)
	{
		if(!(results.Length >= 19)){
			throw new IndexOutOfRangeException("Number of elements in results array is not enough to accomodate positions");
		}
		for (byte i = 0; i < 19; i++) {
			results[i] = GetMidPointPos(center,length,i);
		}

		return;
	}
	
}